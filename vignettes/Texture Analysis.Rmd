---
title: "Texture Analysis"
author: "Joel Carlson"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

Texture analysis is a technique used to quanitfy the patterns in images that are so simple for humans to see, but prove more difficult for computers. The texture analysis features which can be computed using this package can be used as inputs for a classification algorithm, or for visualization of different image properties. In this vignette we will first walk through a basic introduction to the different matrices used to quantify texture, then use these matrices to calculate features of a set of images, and finally use those features to classify the images.


##First order features

Included in the package is a method for calculating several first-order features of images. First-order features are features which rely only on the values of individual pixels in the image, and do not express their relationship to other image pixels. For example, the mean/median/minimum/maximum pixel values in the image.

The first-order features are as follows:


```{r, echo=FALSE, results='asis', fig.cap = "First-order features.", eval=FALSE}

knitr::kable(data.frame("Feature"=c("Energy", "Entropy", "Kurtosis", 
                                    "Mean Deviation","Skewness","Uniformity",
                                    "Mean","Median","Maximum","Minimum",
                                    "Difference","Variance","Root Mean Square","Standard Deviation")))
```

##Gray Level Co-occurrence Matrix (GLCM)

The GLCM is a matrix which considers the spatial relationships between two pixels at a time in the image (the reference and the neighbor pixel). The neighbor pixel can be to the East (0), North-East (45), North (90), or North-West (135) of the reference pixel. The distance between the reference and neighbor pixel can also be chosen. 

The matrix is built such that each row represents a single gray value in the image, and each column also represents a single gray value. The entries of the matrix consist of the number of the times each gray level in a reference position occurs with each other gray level in the neighbor position. The matrix is then added to it's transpose to create a symmetrical matrix

###A simple matrix example

```{r,echo=FALSE, message=FALSE}
library(fields)
devtools::load_all(".")
radiomics::hallbey
```

would have a GLCM with angle = 0, and distance = 1, of:

```{r}
glcm(hallbey, angle="0", d=1, normalize=F)
```

We can see that the grey value of 2 (third row) with a grey value of 3 (fourth column) only ever occurs once in the matrix. Whereas the grey value of 2 occurs 3 times beside another gray value of two (remember, the transpose is added to the matrix, so values on the diagonal are doubled).

For more information on the GLCM see [here](http://www.fp.ucalgary.ca/mhallbey/tutorial.htm) and for the seminal 1974 paper, see [here](http://haralick.org/journals/TexturalFeatures.pdf) (Warning: PDF download)

###A GLCM for a noise image

The glcm for an image composed of noise should also be noise, as there is no relationship between the pixels, we can see that here:

```{r, echo=FALSE, fig.show='hold'}
test <- matrix(sample(1:100, 2500, replace=TRUE), nrow=50)
testGLCM <- glcm(test, n_grey=32, v=F)

image.plot(discretizeImage(test, n_grey=32, v=F), axes=FALSE,xlab="",ylab="", nlevel=length(unique(c(test))))
z<-test
par(mfrow=c(2,2))
a <- glcm(z, angle="0",n_grey=16, normalize=F)
image.plot(a,  axes=FALSE,xlab="",ylab="", nlevel=length(unique(c(a))))
title(main = "0", font.main = 4)
axis(1, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
axis(2, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
a <- glcm(z, angle="45",n_grey=16, normalize=F)
image.plot(a,  axes=FALSE,xlab="",ylab="", nlevel=length(unique(c(a))))
title(main = "45", font.main = 4)
axis(1, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
axis(2, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
a <- glcm(z, angle="90",n_grey=16, normalize=F)
image.plot(a, axes=FALSE,xlab="",ylab="", nlevel=length(unique(c(a))))
title(main = "90", font.main = 4)
axis(1, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
axis(2, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
a <- glcm(z, angle="135",n_grey=16, normalize=F)
image.plot(a,  axes=FALSE,xlab="",ylab="", nlevel=length(unique(c(a))))
title(main = "135", font.main = 4)
axis(1, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
axis(2, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
```

We can see that there is no meaningul information in the noise.

###Vertical Bars

In this case, we expect the 90 degree GLCM to have each grey level occurring only with itself, and for the other angles for the grey levels to only occur with their immediate neighbors.

```{r, echo=FALSE, fig.show='hold'}
z <- matrix(sort(rep(seq(1,20,1),20)),nrow=20)
par(mfrow=c(1,1))
image.plot(t(z), axes=FALSE,xlab="",ylab="", nlevel=length(unique(c(z))))
par(mfrow=c(2,2))
a <- glcm(z, angle="0",n_grey=20, v=F, normalize=F)
image.plot(a,  axes=FALSE,xlab="",ylab="", nlevel=length(unique(c(a))), lab.breaks=c(0,25,50))
title(main = "0", font.main = 4)
axis(1, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
axis(2, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
a <- glcm(z, angle="45",n_grey=20, v=F, normalize=F)
image.plot(a,  axes=FALSE,xlab="",ylab="", nlevel=2, lab.breaks=c(0,25,50))
title(main = "45", font.main = 4)
axis(1, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
axis(2, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
a <- glcm(z, angle="90",n_grey=20, v=F, normalize=F)
image.plot(a,  axes=FALSE,xlab="",ylab="", nlevel=length(unique(c(a))),lab.breaks=c(0,50,100))
title(main = "90", font.main = 4)
axis(1, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
axis(2, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
a <- glcm(z, angle="135",n_grey=20, v=F, normalize=F)
image.plot(a,  axes=FALSE,xlab="",ylab="", nlevel=length(unique(c(a))),lab.breaks=c(0,25,50))
title(main = "135", font.main = 4)
axis(1, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
axis(2, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
```

###A Gaussian Distribution

Since a gaussian distribution is symmetrical at all angles, we expect all of the GLCMs to be identical.

```{r,echo=FALSE, message=FALSE, fig.show='hold'}
library(mvtnorm)
x1 = seq(-5, 5, length.out=50)
x2 = seq(-5, 5, length.out=50)
z = matrix(0, length(x1), length(x2))
for (i in 1:length(x1)) {
    a = x1
    b = x2[i]
    z[,i] = dmvnorm(cbind(a,b), log=TRUE)
}

par(mfrow=c(1,1))

image.plot(discretizeImage(z, n_grey=32, v=F), axes=FALSE,xlab="",ylab="")

par(mfrow=c(2,2))
a <- glcm(z, angle="0",n_grey=32, v=F, normalize=F)
image.plot(a,  axes=FALSE,xlab="",ylab="", nlevel=length(unique(c(a))))
title(main = "0", font.main = 4)
axis(1, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
axis(2, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
a <- glcm(z, angle="45",n_grey=32, v=F, normalize=F)
image.plot(a,  axes=FALSE,xlab="",ylab="", nlevel=length(unique(c(a))))
title(main = "45", font.main = 4)
axis(1, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
axis(2, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
a <- glcm(z, angle="90",n_grey=32, v=F, normalize=F)
image.plot(a,  axes=FALSE,xlab="",ylab="", nlevel=length(unique(c(a))))
title(main = "90", font.main = 4)
axis(1, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
axis(2, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
a <- glcm(z, angle="135",n_grey=32, v=F, normalize=F)
image.plot(a,  axes=FALSE,xlab="",ylab="", nlevel=length(unique(c(a))))
title(main = "135", font.main = 4)
axis(1, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
axis(2, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
```

###A Tumor Image

Here is what the GLCM for a real image of a brain looks like.

```{r, echo=FALSE, message=FALSE, fig.show='hold'}
library(nat)
dir <- "C:/Users/Administrator/Desktop/Radiomics/3D Slicer/TumorRegistration/"
reg <- read.nrrd(paste0(dir, "Registration Result.nrrd"))
im <- reg[1:length(attr(reg, "x")),1:length(attr(reg, "y")), 1:length(attr(reg, "z"))]

par(mfrow=c(1,1))
z<-im[,,15]
image.plot(discretizeImage(z, n_grey=16, v=F), axes=FALSE,xlab="",ylab="", nlevel=length(unique(c(im))))

par(mfrow=c(2,2))
a <- glcm(z, angle="0",n_grey=16, v=F, normalize=F)
image.plot(a,  axes=FALSE,xlab="",ylab="", nlevel=length(unique(c(a))))
title(main = "0", font.main = 4)
axis(1, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
axis(2, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
a <- glcm(z, angle="45",n_grey=16, v=F, normalize=F)
image.plot(a,  axes=FALSE,xlab="",ylab="", nlevel=length(unique(c(a))))
title(main = "45", font.main = 4)
axis(1, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
axis(2, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
a <- glcm(z, angle="90",n_grey=16, v=F, normalize=F)
image.plot(a,  axes=FALSE,xlab="",ylab="", nlevel=length(unique(c(a))))
title(main = "90", font.main = 4)
axis(1, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
axis(2, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
a <- glcm(z, angle="135",n_grey=16, v=F, normalize=F)
image.plot(a,  axes=FALSE,xlab="",ylab="", nlevel=length(unique(c(a))))
title(main = "135", font.main = 4)
axis(1, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
axis(2, at=seq(0,1, length.out=ncol(a)), labels=colnames(a))
```

##Gray Level Run Length Matrix (GLRLM)

The GLRLM is another type of matrix mean to quantify texture. Rather than looking at pairs of pixels, the GLRLM looks at runs of pixels. That is, how many pixels of a given grey value occur in a sequence in a given direction.

The rows of the GLRLM represent, again, grey levels in the image. However, the columns now represent lengths of runs, with the entries corresponding to the number of runs of the given length in the image. Let's look at the example matrix used the Galloway 1974.

```{r,echo=FALSE}
s <- matrix(c(0,1,2,3,0,2,3,3,2,1,1,1,3,0,3,0), nrow=4, byrow=T) #from Galloway 1974
s
```

And the GLRLM:

```{r}
glrlm(s, angle="0", v=F)
```

To note, the GLRLM does not allow grey values of zero, so all of the grey values have been increased by 1.
We can see, from the GLRLM, that in our matrix there are 3 runs of the grey value 4 that are of length 1, and a single run length 2 of the grey value 4.




Vignettes are long form documentation commonly included in packages. Because they are part of the distribution of the package, they need to be as compact as possible. The `html_vignette` output type provides a custom style sheet (and tweaks some options) to ensure that the resulting html is as small as possible. The `html_vignette` format:

- Never uses retina figures
- Has a smaller default figure size
- Uses a custom CSS stylesheet instead of the default Twitter Bootstrap style

## Vignette Info

Note the various macros within the `vignette` setion of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette.

## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis', }
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))
